{
  "version": 3,
  "sources": ["../../@supabase/node-fetch/browser.js", "../../@supabase/postgrest-js/src/PostgrestError.ts", "../../@supabase/postgrest-js/src/PostgrestBuilder.ts", "../../@supabase/postgrest-js/src/PostgrestTransformBuilder.ts", "../../@supabase/postgrest-js/src/PostgrestFilterBuilder.ts", "../../@supabase/postgrest-js/src/PostgrestQueryBuilder.ts", "../../@supabase/postgrest-js/src/PostgrestClient.ts", "../../@supabase/postgrest-js/src/index.ts", "../../@supabase/postgrest-js/dist/esm/wrapper.mjs", "../../@insforge/sdk/src/types.ts", "../../@insforge/sdk/src/lib/http-client.ts", "../../@insforge/sdk/src/lib/token-manager.ts", "../../@insforge/sdk/src/modules/database-postgrest.ts", "../../@insforge/sdk/src/modules/auth.ts", "../../@insforge/sdk/src/modules/storage.ts", "../../@insforge/sdk/src/modules/ai.ts", "../../@insforge/sdk/src/modules/functions.ts", "../../@insforge/sdk/src/client.ts", "../../@insforge/sdk/src/index.ts"],
  "sourcesContent": ["\"use strict\";\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function() {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') { return self; }\n    if (typeof window !== 'undefined') { return window; }\n    if (typeof global !== 'undefined') { return global; }\n    throw new Error('unable to locate global object');\n}\n\nvar globalObject = getGlobal();\n\nexport const fetch = globalObject.fetch;\n\nexport default globalObject.fetch.bind(globalObject);\n\nexport const Headers = globalObject.Headers;\nexport const Request = globalObject.Request;\nexport const Response = globalObject.Response;\n", "/**\n * Error format\n *\n * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n */\nexport default class PostgrestError extends Error {\n  details: string\n  hint: string\n  code: string\n\n  constructor(context: { message: string; details: string; hint: string; code: string }) {\n    super(context.message)\n    this.name = 'PostgrestError'\n    this.details = context.details\n    this.hint = context.hint\n    this.code = context.code\n  }\n}\n", "// @ts-ignore\nimport nodeFetch from '@supabase/node-fetch'\n\nimport type {\n  Fetch,\n  PostgrestSingleResponse,\n  PostgrestResponseSuccess,\n  CheckMatchingArrayTypes,\n  MergePartialResult,\n  IsValidResultOverride,\n  ClientServerOptions,\n} from './types'\nimport PostgrestError from './PostgrestError'\nimport { ContainsNull } from './select-query-parser/types'\n\nexport default abstract class PostgrestBuilder<\n  ClientOptions extends ClientServerOptions,\n  Result,\n  ThrowOnError extends boolean = false\n> implements\n    PromiseLike<\n      ThrowOnError extends true ? PostgrestResponseSuccess<Result> : PostgrestSingleResponse<Result>\n    >\n{\n  protected method: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n  protected url: URL\n  protected headers: Headers\n  protected schema?: string\n  protected body?: unknown\n  protected shouldThrowOnError = false\n  protected signal?: AbortSignal\n  protected fetch: Fetch\n  protected isMaybeSingle: boolean\n\n  constructor(builder: {\n    method: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n    url: URL\n    headers: HeadersInit\n    schema?: string\n    body?: unknown\n    shouldThrowOnError?: boolean\n    signal?: AbortSignal\n    fetch?: Fetch\n    isMaybeSingle?: boolean\n  }) {\n    this.method = builder.method\n    this.url = builder.url\n    this.headers = new Headers(builder.headers)\n    this.schema = builder.schema\n    this.body = builder.body\n    this.shouldThrowOnError = builder.shouldThrowOnError ?? false\n    this.signal = builder.signal\n    this.isMaybeSingle = builder.isMaybeSingle ?? false\n\n    if (builder.fetch) {\n      this.fetch = builder.fetch\n    } else if (typeof fetch === 'undefined') {\n      this.fetch = nodeFetch\n    } else {\n      this.fetch = fetch\n    }\n  }\n\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n  throwOnError(): this & PostgrestBuilder<ClientOptions, Result, true> {\n    this.shouldThrowOnError = true\n    return this as this & PostgrestBuilder<ClientOptions, Result, true>\n  }\n\n  /**\n   * Set an HTTP header for the request.\n   */\n  setHeader(name: string, value: string): this {\n    this.headers = new Headers(this.headers)\n    this.headers.set(name, value)\n    return this\n  }\n\n  then<\n    TResult1 = ThrowOnError extends true\n      ? PostgrestResponseSuccess<Result>\n      : PostgrestSingleResponse<Result>,\n    TResult2 = never\n  >(\n    onfulfilled?:\n      | ((\n          value: ThrowOnError extends true\n            ? PostgrestResponseSuccess<Result>\n            : PostgrestSingleResponse<Result>\n        ) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): PromiseLike<TResult1 | TResult2> {\n    // https://postgrest.org/en/stable/api.html#switching-schemas\n    if (this.schema === undefined) {\n      // skip\n    } else if (['GET', 'HEAD'].includes(this.method)) {\n      this.headers.set('Accept-Profile', this.schema)\n    } else {\n      this.headers.set('Content-Profile', this.schema)\n    }\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\n      this.headers.set('Content-Type', 'application/json')\n    }\n\n    // NOTE: Invoke w/o `this` to avoid illegal invocation error.\n    // https://github.com/supabase/postgrest-js/pull/247\n    const _fetch = this.fetch\n    let res = _fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal,\n    }).then(async (res) => {\n      let error = null\n      let data = null\n      let count: number | null = null\n      let status = res.status\n      let statusText = res.statusText\n\n      if (res.ok) {\n        if (this.method !== 'HEAD') {\n          const body = await res.text()\n          if (body === '') {\n            // Prefer: return=minimal\n          } else if (this.headers.get('Accept') === 'text/csv') {\n            data = body\n          } else if (\n            this.headers.get('Accept') &&\n            this.headers.get('Accept')?.includes('application/vnd.pgrst.plan+text')\n          ) {\n            data = body\n          } else {\n            data = JSON.parse(body)\n          }\n        }\n\n        const countHeader = this.headers.get('Prefer')?.match(/count=(exact|planned|estimated)/)\n        const contentRange = res.headers.get('content-range')?.split('/')\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1])\n        }\n\n        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n        if (this.isMaybeSingle && this.method === 'GET' && Array.isArray(data)) {\n          if (data.length > 1) {\n            error = {\n              // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553\n              code: 'PGRST116',\n              details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n              hint: null,\n              message: 'JSON object requested, multiple (or no) rows returned',\n            }\n            data = null\n            count = null\n            status = 406\n            statusText = 'Not Acceptable'\n          } else if (data.length === 1) {\n            data = data[0]\n          } else {\n            data = null\n          }\n        }\n      } else {\n        const body = await res.text()\n\n        try {\n          error = JSON.parse(body)\n\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (Array.isArray(error) && res.status === 404) {\n            data = []\n            error = null\n            status = 200\n            statusText = 'OK'\n          }\n        } catch {\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (res.status === 404 && body === '') {\n            status = 204\n            statusText = 'No Content'\n          } else {\n            error = {\n              message: body,\n            }\n          }\n        }\n\n        if (error && this.isMaybeSingle && error?.details?.includes('0 rows')) {\n          error = null\n          status = 200\n          statusText = 'OK'\n        }\n\n        if (error && this.shouldThrowOnError) {\n          throw new PostgrestError(error)\n        }\n      }\n\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status,\n        statusText,\n      }\n\n      return postgrestResponse\n    })\n    if (!this.shouldThrowOnError) {\n      res = res.catch((fetchError) => ({\n        error: {\n          message: `${fetchError?.name ?? 'FetchError'}: ${fetchError?.message}`,\n          details: `${fetchError?.stack ?? ''}`,\n          hint: '',\n          code: `${fetchError?.code ?? ''}`,\n        },\n        data: null,\n        count: null,\n        status: 0,\n        statusText: '',\n      }))\n    }\n\n    return res.then(onfulfilled, onrejected)\n  }\n\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n   */\n  returns<NewResult>(): PostgrestBuilder<\n    ClientOptions,\n    CheckMatchingArrayTypes<Result, NewResult>,\n    ThrowOnError\n  > {\n    /* istanbul ignore next */\n    return this as unknown as PostgrestBuilder<\n      ClientOptions,\n      CheckMatchingArrayTypes<Result, NewResult>,\n      ThrowOnError\n    >\n  }\n\n  /**\n   * Override the type of the returned `data` field in the response.\n   *\n   * @typeParam NewResult - The new type to cast the response data to\n   * @typeParam Options - Optional type configuration (defaults to { merge: true })\n   * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n   * @example\n   * ```typescript\n   * // Merge with existing types (default behavior)\n   * const query = supabase\n   *   .from('users')\n   *   .select()\n   *   .overrideTypes<{ custom_field: string }>()\n   *\n   * // Replace existing types completely\n   * const replaceQuery = supabase\n   *   .from('users')\n   *   .select()\n   *   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n   * ```\n   * @returns A PostgrestBuilder instance with the new type\n   */\n  overrideTypes<\n    NewResult,\n    Options extends { merge?: boolean } = { merge: true }\n  >(): PostgrestBuilder<\n    ClientOptions,\n    IsValidResultOverride<Result, NewResult, false, false> extends true\n      ? // Preserve the optionality of the result if the overriden type is an object (case of chaining with `maybeSingle`)\n        ContainsNull<Result> extends true\n        ? MergePartialResult<NewResult, NonNullable<Result>, Options> | null\n        : MergePartialResult<NewResult, Result, Options>\n      : CheckMatchingArrayTypes<Result, NewResult>,\n    ThrowOnError\n  > {\n    return this as unknown as PostgrestBuilder<\n      ClientOptions,\n      IsValidResultOverride<Result, NewResult, false, false> extends true\n        ? // Preserve the optionality of the result if the overriden type is an object (case of chaining with `maybeSingle`)\n          ContainsNull<Result> extends true\n          ? MergePartialResult<NewResult, NonNullable<Result>, Options> | null\n          : MergePartialResult<NewResult, Result, Options>\n        : CheckMatchingArrayTypes<Result, NewResult>,\n      ThrowOnError\n    >\n  }\n}\n", "import PostgrestBuilder from './PostgrestBuilder'\nimport { InvalidMethodError } from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser/result'\nimport {\n  GenericSchema,\n  CheckMatchingArrayTypes,\n  ClientServerOptions,\n  MaxAffectedEnabled,\n} from './types'\n\nexport default class PostgrestTransformBuilder<\n  ClientOptions extends ClientServerOptions,\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result,\n  RelationName = unknown,\n  Relationships = unknown,\n  Method = unknown\n> extends PostgrestBuilder<ClientOptions, Result> {\n  /**\n   * Perform a SELECT on the query result.\n   *\n   * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n   * return modified rows. By calling this method, modified rows are returned in\n   * `data`.\n   *\n   * @param columns - The columns to retrieve, separated by commas\n   */\n  select<\n    Query extends string = '*',\n    NewResultOne = GetResult<Schema, Row, RelationName, Relationships, Query, ClientOptions>\n  >(\n    columns?: Query\n  ): PostgrestTransformBuilder<\n    ClientOptions,\n    Schema,\n    Row,\n    NewResultOne[],\n    RelationName,\n    Relationships,\n    Method\n  > {\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    this.headers.append('Prefer', 'return=representation')\n    return this as unknown as PostgrestTransformBuilder<\n      ClientOptions,\n      Schema,\n      Row,\n      NewResultOne[],\n      RelationName,\n      Relationships,\n      Method\n    >\n  }\n\n  order<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: undefined }\n  ): this\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: string }\n  ): this\n  /**\n   * @deprecated Use `options.referencedTable` instead of `options.foreignTable`\n   */\n  order<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: undefined }\n  ): this\n  /**\n   * @deprecated Use `options.referencedTable` instead of `options.foreignTable`\n   */\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: string }\n  ): this\n  /**\n   * Order the query result by `column`.\n   *\n   * You can call this method multiple times to order by multiple columns.\n   *\n   * You can order referenced tables, but it only affects the ordering of the\n   * parent table if you use `!inner` in the query.\n   *\n   * @param column - The column to order by\n   * @param options - Named parameters\n   * @param options.ascending - If `true`, the result will be in ascending order\n   * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n   * `null`s appear last.\n   * @param options.referencedTable - Set this to order a referenced table by\n   * its columns\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  order(\n    column: string,\n    {\n      ascending = true,\n      nullsFirst,\n      foreignTable,\n      referencedTable = foreignTable,\n    }: {\n      ascending?: boolean\n      nullsFirst?: boolean\n      foreignTable?: string\n      referencedTable?: string\n    } = {}\n  ): this {\n    const key = referencedTable ? `${referencedTable}.order` : 'order'\n    const existingOrder = this.url.searchParams.get(key)\n\n    this.url.searchParams.set(\n      key,\n      `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${\n        nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'\n      }`\n    )\n    return this\n  }\n\n  /**\n   * Limit the query result by `count`.\n   *\n   * @param count - The maximum number of rows to return\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to limit rows of referenced\n   * tables instead of the parent table\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  limit(\n    count: number,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const key = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`\n    this.url.searchParams.set(key, `${count}`)\n    return this\n  }\n\n  /**\n   * Limit the query result by starting at an offset `from` and ending at the offset `to`.\n   * Only records within this range are returned.\n   * This respects the query order and if there is no order clause the range could behave unexpectedly.\n   * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n   * and fourth rows of the query.\n   *\n   * @param from - The starting index from which to limit the result\n   * @param to - The last index to which to limit the result\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to limit rows of referenced\n   * tables instead of the parent table\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  range(\n    from: number,\n    to: number,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const keyOffset =\n      typeof referencedTable === 'undefined' ? 'offset' : `${referencedTable}.offset`\n    const keyLimit = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`\n    this.url.searchParams.set(keyOffset, `${from}`)\n    // Range is inclusive, so add 1\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`)\n    return this\n  }\n\n  /**\n   * Set the AbortSignal for the fetch request.\n   *\n   * @param signal - The AbortSignal to use for the fetch request\n   */\n  abortSignal(signal: AbortSignal): this {\n    this.signal = signal\n    return this\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n   * returns an error.\n   */\n  single<ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never>(): PostgrestBuilder<\n    ClientOptions,\n    ResultOne\n  > {\n    this.headers.set('Accept', 'application/vnd.pgrst.object+json')\n    return this as unknown as PostgrestBuilder<ClientOptions, ResultOne>\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n   * this returns an error.\n   */\n  maybeSingle<\n    ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never\n  >(): PostgrestBuilder<ClientOptions, ResultOne | null> {\n    // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n    // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n    if (this.method === 'GET') {\n      this.headers.set('Accept', 'application/json')\n    } else {\n      this.headers.set('Accept', 'application/vnd.pgrst.object+json')\n    }\n    this.isMaybeSingle = true\n    return this as unknown as PostgrestBuilder<ClientOptions, ResultOne | null>\n  }\n\n  /**\n   * Return `data` as a string in CSV format.\n   */\n  csv(): PostgrestBuilder<ClientOptions, string> {\n    this.headers.set('Accept', 'text/csv')\n    return this as unknown as PostgrestBuilder<ClientOptions, string>\n  }\n\n  /**\n   * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n   */\n  geojson(): PostgrestBuilder<ClientOptions, Record<string, unknown>> {\n    this.headers.set('Accept', 'application/geo+json')\n    return this as unknown as PostgrestBuilder<ClientOptions, Record<string, unknown>>\n  }\n\n  /**\n   * Return `data` as the EXPLAIN plan for the query.\n   *\n   * You need to enable the\n   * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n   * setting before using this method.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.analyze - If `true`, the query will be executed and the\n   * actual run time will be returned\n   *\n   * @param options.verbose - If `true`, the query identifier will be returned\n   * and `data` will include the output columns of the query\n   *\n   * @param options.settings - If `true`, include information on configuration\n   * parameters that affect query planning\n   *\n   * @param options.buffers - If `true`, include information on buffer usage\n   *\n   * @param options.wal - If `true`, include information on WAL record generation\n   *\n   * @param options.format - The format of the output, can be `\"text\"` (default)\n   * or `\"json\"`\n   */\n  explain({\n    analyze = false,\n    verbose = false,\n    settings = false,\n    buffers = false,\n    wal = false,\n    format = 'text',\n  }: {\n    analyze?: boolean\n    verbose?: boolean\n    settings?: boolean\n    buffers?: boolean\n    wal?: boolean\n    format?: 'json' | 'text'\n  } = {}) {\n    const options = [\n      analyze ? 'analyze' : null,\n      verbose ? 'verbose' : null,\n      settings ? 'settings' : null,\n      buffers ? 'buffers' : null,\n      wal ? 'wal' : null,\n    ]\n      .filter(Boolean)\n      .join('|')\n    // An Accept header can carry multiple media types but postgrest-js always sends one\n    const forMediatype = this.headers.get('Accept') ?? 'application/json'\n    this.headers.set(\n      'Accept',\n      `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`\n    )\n    if (format === 'json') {\n      return this as unknown as PostgrestBuilder<ClientOptions, Record<string, unknown>[]>\n    } else {\n      return this as unknown as PostgrestBuilder<ClientOptions, string>\n    }\n  }\n\n  /**\n   * Rollback the query.\n   *\n   * `data` will still be returned, but the query is not committed.\n   */\n  rollback(): this {\n    this.headers.append('Prefer', 'tx=rollback')\n    return this\n  }\n\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n   */\n  returns<NewResult>(): PostgrestTransformBuilder<\n    ClientOptions,\n    Schema,\n    Row,\n    CheckMatchingArrayTypes<Result, NewResult>,\n    RelationName,\n    Relationships,\n    Method\n  > {\n    return this as unknown as PostgrestTransformBuilder<\n      ClientOptions,\n      Schema,\n      Row,\n      CheckMatchingArrayTypes<Result, NewResult>,\n      RelationName,\n      Relationships,\n      Method\n    >\n  }\n\n  /**\n   * Set the maximum number of rows that can be affected by the query.\n   * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n   *\n   * @param value - The maximum number of rows that can be affected\n   */\n  maxAffected(value: number): MaxAffectedEnabled<ClientOptions['PostgrestVersion']> extends true\n    ? // TODO: update the RPC case to only work on RPC that returns SETOF rows\n      Method extends 'PATCH' | 'DELETE' | 'RPC'\n      ? this\n      : InvalidMethodError<'maxAffected method only available on update or delete'>\n    : InvalidMethodError<'maxAffected method only available on postgrest 13+'> {\n    this.headers.append('Prefer', 'handling=strict')\n    this.headers.append('Prefer', `max-affected=${value}`)\n    return this as unknown as MaxAffectedEnabled<ClientOptions['PostgrestVersion']> extends true\n      ? Method extends 'PATCH' | 'DELETE' | 'RPC'\n        ? this\n        : InvalidMethodError<'maxAffected method only available on update or delete'>\n      : InvalidMethodError<'maxAffected method only available on postgrest 13+'>\n  }\n}\n", "import PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport { JsonPathToAccessor, JsonPathToType } from './select-query-parser/utils'\nimport { ClientServerOptions, GenericSchema } from './types'\n\ntype FilterOperator =\n  | 'eq'\n  | 'neq'\n  | 'gt'\n  | 'gte'\n  | 'lt'\n  | 'lte'\n  | 'like'\n  | 'ilike'\n  | 'is'\n  | 'in'\n  | 'cs'\n  | 'cd'\n  | 'sl'\n  | 'sr'\n  | 'nxl'\n  | 'nxr'\n  | 'adj'\n  | 'ov'\n  | 'fts'\n  | 'plfts'\n  | 'phfts'\n  | 'wfts'\n\nexport type IsStringOperator<Path extends string> = Path extends `${string}->>${string}`\n  ? true\n  : false\n\n// Match relationship filters with `table.column` syntax and resolve underlying\n// column value. If not matched, fallback to generic type.\n// TODO: Validate the relationship itself ala select-query-parser. Currently we\n// assume that all tables have valid relationships to each other, despite\n// nonexistent foreign keys.\ntype ResolveFilterValue<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  ColumnName extends string\n> = ColumnName extends `${infer RelationshipTable}.${infer Remainder}`\n  ? Remainder extends `${infer _}.${infer _}`\n    ? ResolveFilterValue<Schema, Row, Remainder>\n    : ResolveFilterRelationshipValue<Schema, RelationshipTable, Remainder>\n  : ColumnName extends keyof Row\n  ? Row[ColumnName]\n  : // If the column selection is a jsonpath like `data->value` or `data->>value` we attempt to match\n  // the expected type with the parsed custom json type\n  IsStringOperator<ColumnName> extends true\n  ? string\n  : JsonPathToType<Row, JsonPathToAccessor<ColumnName>> extends infer JsonPathValue\n  ? JsonPathValue extends never\n    ? never\n    : JsonPathValue\n  : never\n\ntype ResolveFilterRelationshipValue<\n  Schema extends GenericSchema,\n  RelationshipTable extends string,\n  RelationshipColumn extends string\n> = Schema['Tables'] & Schema['Views'] extends infer TablesAndViews\n  ? RelationshipTable extends keyof TablesAndViews\n    ? 'Row' extends keyof TablesAndViews[RelationshipTable]\n      ? RelationshipColumn extends keyof TablesAndViews[RelationshipTable]['Row']\n        ? TablesAndViews[RelationshipTable]['Row'][RelationshipColumn]\n        : unknown\n      : unknown\n    : unknown\n  : never\n\nexport type InvalidMethodError<S extends string> = { Error: S }\n\nexport default class PostgrestFilterBuilder<\n  ClientOptions extends ClientServerOptions,\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result,\n  RelationName = unknown,\n  Relationships = unknown,\n  Method = unknown\n> extends PostgrestTransformBuilder<\n  ClientOptions,\n  Schema,\n  Row,\n  Result,\n  RelationName,\n  Relationships,\n  Method\n> {\n  /**\n   * Match only rows where `column` is equal to `value`.\n   *\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  eq<ColumnName extends string>(\n    column: ColumnName,\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\n      ? NonNullable<unknown>\n      : // We want to infer the type before wrapping it into a `NonNullable` to avoid too deep\n      // type resolution error\n      ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n      ? NonNullable<ResolvedFilterValue>\n      : // We should never enter this case as all the branches are covered above\n        never\n  ): this {\n    this.url.searchParams.append(column, `eq.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is not equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  neq<ColumnName extends string>(\n    column: ColumnName,\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\n      ? unknown\n      : ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n      ? ResolvedFilterValue\n      : never\n  ): this {\n    this.url.searchParams.append(column, `neq.${value}`)\n    return this\n  }\n\n  gt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gt.${value}`)\n    return this\n  }\n\n  gte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gte.${value}`)\n    return this\n  }\n\n  lt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lt.${value}`)\n    return this\n  }\n\n  lte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lte.${value}`)\n    return this\n  }\n\n  like<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  like(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  like(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `like.${pattern}`)\n    return this\n  }\n\n  likeAllOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  likeAllOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAllOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  likeAnyOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  likeAnyOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAnyOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilike<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  ilike(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  ilike(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `ilike.${pattern}`)\n    return this\n  }\n\n  ilikeAllOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  ilikeAllOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAllOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilikeAnyOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  ilikeAnyOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAnyOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  is<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: Row[ColumnName] & (boolean | null)\n  ): this\n  is(column: string, value: boolean | null): this\n  /**\n   * Match only rows where `column` IS `value`.\n   *\n   * For non-boolean columns, this is only relevant for checking if the value of\n   * `column` is NULL by setting `value` to `null`.\n   *\n   * For boolean columns, you can also set `value` to `true` or `false` and it\n   * will behave the same way as `.eq()`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  is(column: string, value: boolean | null): this {\n    this.url.searchParams.append(column, `is.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is included in the `values` array.\n   *\n   * @param column - The column to filter on\n   * @param values - The values array to filter with\n   */\n  in<ColumnName extends string>(\n    column: ColumnName,\n    values: ReadonlyArray<\n      ResolveFilterValue<Schema, Row, ColumnName> extends never\n        ? unknown\n        : // We want to infer the type before wrapping it into a `NonNullable` to avoid too deep\n        // type resolution error\n        ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n        ? ResolvedFilterValue\n        : // We should never enter this case as all the branches are covered above\n          never\n    >\n  ): this {\n    const cleanedValues = Array.from(new Set(values))\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(column, `in.(${cleanedValues})`)\n    return this\n  }\n\n  contains<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\n  ): this\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * `column` contains every element appearing in `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(column, `cs.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cs.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  containedBy<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\n  ): this\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * every element appearing in `column` is contained by `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `cd.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cd.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  rangeGt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is greater than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sr.${range}`)\n    return this\n  }\n\n  rangeGte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or greater than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxl.${range}`)\n    return this\n  }\n\n  rangeLt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is less than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sl.${range}`)\n    return this\n  }\n\n  rangeLte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or less than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxr.${range}`)\n    return this\n  }\n\n  rangeAdjacent<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeAdjacent(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where `column` is\n   * mutually exclusive to `range` and there can be no element between the two\n   * ranges.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeAdjacent(column: string, range: string): this {\n    this.url.searchParams.append(column, `adj.${range}`)\n    return this\n  }\n\n  overlaps<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]>\n  ): this\n  overlaps(column: string, value: string | readonly unknown[]): this\n  /**\n   * Only relevant for array and range columns. Match only rows where\n   * `column` and `value` have an element in common.\n   *\n   * @param column - The array or range column to filter on\n   * @param value - The array or range value to filter with\n   */\n  overlaps(column: string, value: string | readonly unknown[]): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `ov.${value}`)\n    } else {\n      // array\n      this.url.searchParams.append(column, `ov.{${value.join(',')}}`)\n    }\n    return this\n  }\n\n  textSearch<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  textSearch(\n    column: string,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  /**\n   * Only relevant for text and tsvector columns. Match only rows where\n   * `column` matches the query string in `query`.\n   *\n   * @param column - The text or tsvector column to filter on\n   * @param query - The query text to match with\n   * @param options - Named parameters\n   * @param options.config - The text search configuration to use\n   * @param options.type - Change how the `query` text is interpreted\n   */\n  textSearch(\n    column: string,\n    query: string,\n    { config, type }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' } = {}\n  ): this {\n    let typePart = ''\n    if (type === 'plain') {\n      typePart = 'pl'\n    } else if (type === 'phrase') {\n      typePart = 'ph'\n    } else if (type === 'websearch') {\n      typePart = 'w'\n    }\n    const configPart = config === undefined ? '' : `(${config})`\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`)\n    return this\n  }\n\n  match<ColumnName extends string & keyof Row>(query: Record<ColumnName, Row[ColumnName]>): this\n  match(query: Record<string, unknown>): this\n  /**\n   * Match only rows where each column in `query` keys is equal to its\n   * associated value. Shorthand for multiple `.eq()`s.\n   *\n   * @param query - The object to filter with, with column names as keys mapped\n   * to their filter values\n   */\n  match(query: Record<string, unknown>): this {\n    Object.entries(query).forEach(([column, value]) => {\n      this.url.searchParams.append(column, `eq.${value}`)\n    })\n    return this\n  }\n\n  not<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: FilterOperator,\n    value: Row[ColumnName]\n  ): this\n  not(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which doesn't satisfy the filter.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to be negated to filter with, following\n   * PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  not(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `not.${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows which satisfy at least one of the filters.\n   *\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure it's properly sanitized.\n   *\n   * It's currently not possible to do an `.or()` filter across multiple tables.\n   *\n   * @param filters - The filters to use, following PostgREST syntax\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to filter on referenced tables\n   * instead of the parent table\n   * @param options.foreignTable - Deprecated, use `referencedTable` instead\n   */\n  or(\n    filters: string,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const key = referencedTable ? `${referencedTable}.or` : 'or'\n    this.url.searchParams.append(key, `(${filters})`)\n    return this\n  }\n\n  filter<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: `${'' | 'not.'}${FilterOperator}`,\n    value: unknown\n  ): this\n  filter(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which satisfy the filter. This is an escape hatch - you\n   * should use the specific filter methods wherever possible.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to filter with, following PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  filter(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `${operator}.${value}`)\n    return this\n  }\n}\n", "import PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser/result'\nimport { ClientServerOptions, Fetch, GenericSchema, GenericTable, GenericView } from './types'\n\nexport default class PostgrestQueryBuilder<\n  ClientOptions extends ClientServerOptions,\n  Schema extends GenericSchema,\n  Relation extends GenericTable | GenericView,\n  RelationName = unknown,\n  Relationships = Relation extends { Relationships: infer R } ? R : unknown\n> {\n  url: URL\n  headers: Headers\n  schema?: string\n  signal?: AbortSignal\n  fetch?: Fetch\n\n  constructor(\n    url: URL,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: HeadersInit\n      schema?: string\n      fetch?: Fetch\n    }\n  ) {\n    this.url = url\n    this.headers = new Headers(headers)\n    this.schema = schema\n    this.fetch = fetch\n  }\n\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  select<\n    Query extends string = '*',\n    ResultOne = GetResult<\n      Schema,\n      Relation['Row'],\n      RelationName,\n      Relationships,\n      Query,\n      ClientOptions\n    >\n  >(\n    columns?: Query,\n    {\n      head = false,\n      count,\n    }: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    ResultOne[],\n    RelationName,\n    Relationships,\n    'GET'\n  > {\n    const method = head ? 'HEAD' : 'GET'\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n    })\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk inserts.\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. Only applies for bulk\n   * inserts.\n   */\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      count,\n      defaultToNull = true,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  > {\n    const method = 'POST'\n\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n    if (!defaultToNull) {\n      this.headers.append('Prefer', `missing=default`)\n    }\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk upserts.\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  /**\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n   * exist, or if it does exist, perform an alternative action depending on\n   * `ignoreDuplicates`.\n   *\n   * By default, upserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to upsert with. Pass an object to upsert a\n   * single row or an array to upsert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n   * duplicate rows are determined. Two rows are duplicates if all the\n   * `onConflict` columns are equal.\n   *\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n   * `false`, duplicate rows are merged with existing rows.\n   *\n   * @param options.count - Count algorithm to use to count upserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. This only applies when\n   * inserting new rows, not when merging with existing rows under\n   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n   */\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      onConflict,\n      ignoreDuplicates = false,\n      count,\n      defaultToNull = true,\n    }: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  > {\n    const method = 'POST'\n\n    this.headers.append('Prefer', `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`)\n\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n    if (!defaultToNull) {\n      this.headers.append('Prefer', 'missing=default')\n    }\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  update<Row extends Relation extends { Update: unknown } ? Relation['Update'] : never>(\n    values: Row,\n    {\n      count,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'PATCH'\n  > {\n    const method = 'PATCH'\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  delete({\n    count,\n  }: {\n    count?: 'exact' | 'planned' | 'estimated'\n  } = {}): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'DELETE'\n  > {\n    const method = 'DELETE'\n    if (count) {\n      this.headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n}\n", "import PostgrestQueryBuilder from './PostgrestQueryBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { Fetch, GenericSchema, ClientServerOptions } from './types'\n\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */\nexport default class PostgrestClient<\n  Database = any,\n  ClientOptions extends ClientServerOptions = Database extends {\n    __InternalSupabase: infer I extends ClientServerOptions\n  }\n    ? I\n    : {},\n  SchemaName extends string &\n    keyof Omit<Database, '__InternalSupabase'> = 'public' extends keyof Omit<\n    Database,\n    '__InternalSupabase'\n  >\n    ? 'public'\n    : string & keyof Omit<Database, '__InternalSupabase'>,\n  Schema extends GenericSchema = Omit<\n    Database,\n    '__InternalSupabase'\n  >[SchemaName] extends GenericSchema\n    ? Omit<Database, '__InternalSupabase'>[SchemaName]\n    : any\n> {\n  url: string\n  headers: Headers\n  schemaName?: SchemaName\n  fetch?: Fetch\n\n  // TODO: Add back shouldThrowOnError once we figure out the typings\n  /**\n   * Creates a PostgREST client.\n   *\n   * @param url - URL of the PostgREST endpoint\n   * @param options - Named parameters\n   * @param options.headers - Custom headers\n   * @param options.schema - Postgres schema to switch to\n   * @param options.fetch - Custom fetch\n   */\n  constructor(\n    url: string,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: HeadersInit\n      schema?: SchemaName\n      fetch?: Fetch\n    } = {}\n  ) {\n    this.url = url\n    this.headers = new Headers(headers)\n    this.schemaName = schema\n    this.fetch = fetch\n  }\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName]\n  >(relation: TableName): PostgrestQueryBuilder<ClientOptions, Schema, Table, TableName>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<ClientOptions, Schema, View, ViewName>\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from(relation: string): PostgrestQueryBuilder<ClientOptions, Schema, any, any> {\n    const url = new URL(`${this.url}/${relation}`)\n    return new PostgrestQueryBuilder(url, {\n      headers: new Headers(this.headers),\n      schema: this.schemaName,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Select a schema to query or perform an function (rpc) call.\n   *\n   * The schema needs to be on the list of exposed schemas inside Supabase.\n   *\n   * @param schema - The schema to query\n   */\n  schema<DynamicSchema extends string & keyof Omit<Database, '__InternalSupabase'>>(\n    schema: DynamicSchema\n  ): PostgrestClient<\n    Database,\n    ClientOptions,\n    DynamicSchema,\n    Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\n  > {\n    return new PostgrestClient(this.url, {\n      headers: this.headers,\n      schema,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.get - When set to `true`, the function will be called with\n   * read-only access mode.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  rpc<FnName extends string & keyof Schema['Functions'], Fn extends Schema['Functions'][FnName]>(\n    fn: FnName,\n    args: Fn['Args'] = {},\n    {\n      head = false,\n      get = false,\n      count,\n    }: {\n      head?: boolean\n      get?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Fn['Returns'] extends any[]\n      ? Fn['Returns'][number] extends Record<string, unknown>\n        ? Fn['Returns'][number]\n        : never\n      : never,\n    Fn['Returns'],\n    FnName,\n    null,\n    'RPC'\n  > {\n    let method: 'HEAD' | 'GET' | 'POST'\n    const url = new URL(`${this.url}/rpc/${fn}`)\n    let body: unknown | undefined\n    if (head || get) {\n      method = head ? 'HEAD' : 'GET'\n      Object.entries(args)\n        // params with undefined value needs to be filtered out, otherwise it'll\n        // show up as `?param=undefined`\n        .filter(([_, value]) => value !== undefined)\n        // array values need special syntax\n        .map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(',')}}` : `${value}`])\n        .forEach(([name, value]) => {\n          url.searchParams.append(name, value)\n        })\n    } else {\n      method = 'POST'\n      body = args\n    }\n\n    const headers = new Headers(this.headers)\n    if (count) {\n      headers.set('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schemaName,\n      body,\n      fetch: this.fetch ?? fetch,\n    })\n  }\n}\n", "// Always update wrapper.mjs when updating this file.\nimport PostgrestClient from './PostgrestClient'\nimport PostgrestQueryBuilder from './PostgrestQueryBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport PostgrestBuilder from './PostgrestBuilder'\nimport PostgrestError from './PostgrestError'\n\nexport {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n}\nexport default {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n}\nexport type {\n  PostgrestResponse,\n  PostgrestResponseFailure,\n  PostgrestResponseSuccess,\n  PostgrestSingleResponse,\n  PostgrestMaybeSingleResponse,\n  ClientServerOptions as PostgrestClientOptions,\n} from './types'\n// https://github.com/supabase/postgrest-js/issues/551\n// To be replaced with a helper type that only uses public types\nexport type { GetResult as UnstableGetResult } from './select-query-parser/result'\n", "import index from '../cjs/index.js'\nconst {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n} = index\n\nexport {\n  PostgrestBuilder,\n  PostgrestClient,\n  PostgrestFilterBuilder,\n  PostgrestQueryBuilder,\n  PostgrestTransformBuilder,\n  PostgrestError,\n}\n\n// compatibility with CJS output\nexport default {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n}\n", "/**\n * InsForge SDK Types - only SDK-specific types here\n * Use @insforge/shared-schemas directly for API types\n */\n\nimport type { UserSchema } from '@insforge/shared-schemas';\n\nexport interface InsForgeConfig {\n  /**\n   * The base URL of the InsForge backend API\n   * @default \"http://localhost:7130\"\n   */\n  baseUrl?: string;\n\n  /**\n   * Anonymous API key (optional)\n   * Used for public/unauthenticated requests when no user token is set\n   */\n  anonKey?: string;\n\n  /**\n   * Edge Function Token (optional)\n   * Use this when running in edge functions/serverless with a user's JWT token\n   * This token will be used for all authenticated requests\n   */\n  edgeFunctionToken?: string;\n\n  /**\n   * Custom fetch implementation (useful for Node.js environments)\n   */\n  fetch?: typeof fetch;\n\n  /**\n   * Storage adapter for persisting tokens\n   */\n  storage?: TokenStorage;\n\n  /**\n   * Whether to automatically refresh tokens before they expire\n   * @default true\n   */\n  autoRefreshToken?: boolean;\n\n  /**\n   * Whether to persist session in storage\n   * @default true\n   */\n  persistSession?: boolean;\n\n  /**\n   * Custom headers to include with every request\n   */\n  headers?: Record<string, string>;\n}\n\nexport interface TokenStorage {\n  getItem(key: string): string | null | Promise<string | null>;\n  setItem(key: string, value: string): void | Promise<void>;\n  removeItem(key: string): void | Promise<void>;\n}\n\nexport interface AuthSession {\n  user: UserSchema;\n  accessToken: string;\n  expiresAt?: Date;\n}\n\nexport interface ApiError {\n  error: string;\n  message: string;\n  statusCode: number;\n  nextActions?: string;\n}\n\nexport class InsForgeError extends Error {\n  public statusCode: number;\n  public error: string;\n  public nextActions?: string;\n\n  constructor(message: string, statusCode: number, error: string, nextActions?: string) {\n    super(message);\n    this.name = 'InsForgeError';\n    this.statusCode = statusCode;\n    this.error = error;\n    this.nextActions = nextActions;\n  }\n\n  static fromApiError(apiError: ApiError): InsForgeError {\n    return new InsForgeError(\n      apiError.message,\n      apiError.statusCode,\n      apiError.error,\n      apiError.nextActions\n    );\n  }\n}", "import { InsForgeConfig, ApiError, InsForgeError } from '../types';\n\nexport interface RequestOptions extends RequestInit {\n  params?: Record<string, string>;\n}\n\nexport class HttpClient {\n  public readonly baseUrl: string;\n  public readonly fetch: typeof fetch;\n  private defaultHeaders: Record<string, string>;\n  private anonKey: string | undefined;\n  private userToken: string | null = null;\n\n  constructor(config: InsForgeConfig) {\n    this.baseUrl = config.baseUrl || 'http://localhost:7130';\n    // Properly bind fetch to maintain its context\n    this.fetch = config.fetch || (globalThis.fetch ? globalThis.fetch.bind(globalThis) : undefined as any);\n    this.anonKey = config.anonKey;\n    this.defaultHeaders = {\n      ...config.headers,\n    };\n\n    if (!this.fetch) {\n      throw new Error(\n        'Fetch is not available. Please provide a fetch implementation in the config.'\n      );\n    }\n  }\n\n  private buildUrl(path: string, params?: Record<string, string>): string {\n    const url = new URL(path, this.baseUrl);\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        // For select parameter, preserve the exact formatting by normalizing whitespace\n        // This ensures PostgREST relationship queries work correctly\n        if (key === 'select') {\n          // Normalize multiline select strings for PostgREST:\n          // 1. Replace all whitespace (including newlines) with single space\n          // 2. Remove spaces inside parentheses for proper PostgREST syntax\n          // 3. Keep spaces after commas at the top level for readability\n          let normalizedValue = value.replace(/\\s+/g, ' ').trim();\n          \n          // Fix spaces around parentheses and inside them\n          normalizedValue = normalizedValue\n            .replace(/\\s*\\(\\s*/g, '(')  // Remove spaces around opening parens\n            .replace(/\\s*\\)\\s*/g, ')')  // Remove spaces around closing parens\n            .replace(/\\(\\s+/g, '(')     // Remove spaces after opening parens\n            .replace(/\\s+\\)/g, ')')     // Remove spaces before closing parens\n            .replace(/,\\s+(?=[^()]*\\))/g, ','); // Remove spaces after commas inside parens\n          \n          url.searchParams.append(key, normalizedValue);\n        } else {\n          url.searchParams.append(key, value);\n        }\n      });\n    }\n    return url.toString();\n  }\n\n  async request<T>(\n    method: string,\n    path: string,\n    options: RequestOptions = {}\n  ): Promise<T> {\n    const { params, headers = {}, body, ...fetchOptions } = options;\n    \n    const url = this.buildUrl(path, params);\n    \n    const requestHeaders: Record<string, string> = {\n      ...this.defaultHeaders,\n    };\n    \n    // Set Authorization header: prefer user token, fallback to anon key\n    const authToken = this.userToken || this.anonKey;\n    if (authToken) {\n      requestHeaders['Authorization'] = `Bearer ${authToken}`;\n    }\n    \n    // Handle body serialization\n    let processedBody: any;\n    if (body !== undefined) {\n      // Check if body is FormData (for file uploads)\n      if (typeof FormData !== 'undefined' && body instanceof FormData) {\n        // Don't set Content-Type for FormData, let browser set it with boundary\n        processedBody = body;\n      } else {\n        // JSON body\n        if (method !== 'GET') {\n          requestHeaders['Content-Type'] = 'application/json;charset=UTF-8';\n        }\n        processedBody = JSON.stringify(body);\n      }\n    }\n    \n    Object.assign(requestHeaders, headers);\n    \n    const response = await this.fetch(url, {\n      method,\n      headers: requestHeaders,\n      body: processedBody,\n      ...fetchOptions,\n    });\n\n    // Handle 204 No Content\n    if (response.status === 204) {\n      return undefined as T;\n    }\n\n    // Try to parse JSON response\n    let data: any;\n    const contentType = response.headers.get('content-type');\n    // Check for any JSON content type (including PostgREST's vnd.pgrst.object+json)\n    if (contentType?.includes('json')) {\n      data = await response.json();\n    } else {\n      // For non-JSON responses, return text\n      data = await response.text();\n    }\n\n    // Handle errors\n    if (!response.ok) {\n      if (data && typeof data === 'object' && 'error' in data) {\n        // Add the HTTP status code if not already in the data\n        if (!data.statusCode && !data.status) {\n          data.statusCode = response.status;\n        }\n        const error = InsForgeError.fromApiError(data as ApiError);\n        // Preserve all additional fields from the error response\n        Object.keys(data).forEach(key => {\n          if (key !== 'error' && key !== 'message' && key !== 'statusCode') {\n            (error as any)[key] = data[key];\n          }\n        });\n        throw error;\n      }\n      throw new InsForgeError(\n        `Request failed: ${response.statusText}`,\n        response.status,\n        'REQUEST_FAILED'\n      );\n    }\n\n    return data as T;\n  }\n\n  get<T>(path: string, options?: RequestOptions): Promise<T> {\n    return this.request<T>('GET', path, options);\n  }\n\n  post<T>(path: string, body?: any, options?: RequestOptions): Promise<T> {\n    return this.request<T>('POST', path, { ...options, body });\n  }\n\n  put<T>(path: string, body?: any, options?: RequestOptions): Promise<T> {\n    return this.request<T>('PUT', path, { ...options, body });\n  }\n\n  patch<T>(path: string, body?: any, options?: RequestOptions): Promise<T> {\n    return this.request<T>('PATCH', path, { ...options, body });\n  }\n\n  delete<T>(path: string, options?: RequestOptions): Promise<T> {\n    return this.request<T>('DELETE', path, options);\n  }\n\n  setAuthToken(token: string | null) {\n    this.userToken = token;\n  }\n\n  getHeaders(): Record<string, string> {\n    const headers = { ...this.defaultHeaders };\n    \n    // Include Authorization header if token is available (same logic as request method)\n    const authToken = this.userToken || this.anonKey;\n    if (authToken) {\n      headers['Authorization'] = `Bearer ${authToken}`;\n    }\n    \n    return headers;\n  }\n}", "import { TokenStorage, AuthSession } from '../types';\n\nconst TOKEN_KEY = 'insforge-auth-token';\nconst USER_KEY = 'insforge-auth-user';\n\nexport class TokenManager {\n  private storage: TokenStorage;\n\n  constructor(storage?: TokenStorage) {\n    if (storage) {\n      // Use provided storage\n      this.storage = storage;\n    } else if (typeof window !== 'undefined' && window.localStorage) {\n      // Browser: use localStorage\n      this.storage = window.localStorage;\n    } else {\n      // Node.js: use in-memory storage\n      const store = new Map<string, string>();\n      this.storage = {\n        getItem: (key: string) => store.get(key) || null,\n        setItem: (key: string, value: string) => { store.set(key, value); },\n        removeItem: (key: string) => { store.delete(key); }\n      };\n    }\n  }\n\n  saveSession(session: AuthSession): void {\n    this.storage.setItem(TOKEN_KEY, session.accessToken);\n    this.storage.setItem(USER_KEY, JSON.stringify(session.user));\n  }\n\n  getSession(): AuthSession | null {\n    const token = this.storage.getItem(TOKEN_KEY);\n    const userStr = this.storage.getItem(USER_KEY);\n\n    if (!token || !userStr) {\n      return null;\n    }\n\n    try {\n      const user = JSON.parse(userStr as string);\n      return { accessToken: token as string, user };\n    } catch {\n      this.clearSession();\n      return null;\n    }\n  }\n\n  getAccessToken(): string | null {\n    const token = this.storage.getItem(TOKEN_KEY);\n    return typeof token === 'string' ? token : null;\n  }\n\n  clearSession(): void {\n    this.storage.removeItem(TOKEN_KEY);\n    this.storage.removeItem(USER_KEY);\n  }\n}", "/**\n * Database module using @supabase/postgrest-js\n * Complete replacement for custom QueryBuilder with full PostgREST features\n */\n\nimport { PostgrestClient } from '@supabase/postgrest-js';\nimport { HttpClient } from '../lib/http-client';\nimport { TokenManager } from '../lib/token-manager';\n\n\n/**\n * Custom fetch that transforms URLs and adds auth\n */\nfunction createInsForgePostgrestFetch(\n  httpClient: HttpClient,\n  tokenManager: TokenManager\n): typeof fetch {\n  return async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {\n    const url = typeof input === 'string' ? input : input.toString();\n    const urlObj = new URL(url);\n    \n    // Extract table name from pathname\n    // postgrest-js sends: http://dummy/tablename?params\n    // We need: http://localhost:7130/api/database/records/tablename?params\n    const tableName = urlObj.pathname.slice(1); // Remove leading /\n    \n    // Build InsForge URL\n    const insforgeUrl = `${httpClient.baseUrl}/api/database/records/${tableName}${urlObj.search}`;\n    \n    // Get auth token from TokenManager or HttpClient\n    const token = tokenManager.getAccessToken();\n    const httpHeaders = httpClient.getHeaders();\n    const authToken = token || httpHeaders['Authorization']?.replace('Bearer ', '');\n    \n    // Prepare headers\n    const headers = new Headers(init?.headers);\n    if (authToken && !headers.has('Authorization')) {\n      headers.set('Authorization', `Bearer ${authToken}`);\n    }\n    \n    // Make the actual request using native fetch\n    const response = await fetch(insforgeUrl, {\n      ...init,\n      headers\n    });\n  \n    return response;\n  };\n}\n\n/**\n * Database client using postgrest-js\n * Drop-in replacement with FULL PostgREST capabilities\n */\nexport class Database {\n  private postgrest: PostgrestClient<any, any, any>;\n  \n  constructor(httpClient: HttpClient, tokenManager: TokenManager) {\n    // Create postgrest client with custom fetch\n    this.postgrest = new PostgrestClient<any, any, any>('http://dummy', {\n      fetch: createInsForgePostgrestFetch(httpClient, tokenManager),\n      headers: {}\n    });\n  }\n  \n  /**\n   * Create a query builder for a table\n   * \n   * @example\n   * // Basic query\n   * const { data, error } = await client.database\n   *   .from('posts')\n   *   .select('*')\n   *   .eq('user_id', userId);\n   * \n   * // With count (Supabase style!)\n   * const { data, error, count } = await client.database\n   *   .from('posts')\n   *   .select('*', { count: 'exact' })\n   *   .range(0, 9);\n   * \n   * // Just get count, no data\n   * const { count } = await client.database\n   *   .from('posts')\n   *   .select('*', { count: 'exact', head: true });\n   * \n   * // Complex queries with OR\n   * const { data } = await client.database\n   *   .from('posts')\n   *   .select('*, users!inner(*)')\n   *   .or('status.eq.active,status.eq.pending');\n   * \n   * // All features work:\n   * - Nested selects\n   * - Foreign key expansion  \n   * - OR/AND/NOT conditions\n   * - Count with head\n   * - Range pagination\n   * - Upserts\n   */\n  from(table: string) {\n    // Return postgrest query builder with all features\n    return this.postgrest.from(table);\n  }\n}", "/**\n * Auth module for InsForge SDK\n * Uses shared schemas for type safety\n */\n\nimport { HttpClient } from '../lib/http-client';\nimport { TokenManager } from '../lib/token-manager';\nimport { AuthSession, InsForgeError } from '../types';\nimport { Database } from './database-postgrest';\n\nimport type {\n  CreateUserRequest,\n  CreateUserResponse,\n  CreateSessionRequest,\n  CreateSessionResponse,\n  GetCurrentSessionResponse,\n  GetOauthUrlResponse,\n} from '@insforge/shared-schemas';\n\nexport class Auth {\n  private database: Database;\n  \n  constructor(\n    private http: HttpClient,\n    private tokenManager: TokenManager\n  ) {\n    this.database = new Database(http, tokenManager);\n    \n    // Auto-detect OAuth callback parameters in the URL\n    this.detectOAuthCallback();\n  }\n\n  /**\n   * Automatically detect and handle OAuth callback parameters in the URL\n   * This runs on initialization to seamlessly complete the OAuth flow\n   * Matches the backend's OAuth callback response (backend/src/api/routes/auth.ts:540-544)\n   */\n  private detectOAuthCallback(): void {\n    // Only run in browser environment\n    if (typeof window === 'undefined') return;\n    \n    try {\n      const params = new URLSearchParams(window.location.search);\n      \n      // Backend returns: access_token, user_id, email, name (optional)\n      const accessToken = params.get('access_token');\n      const userId = params.get('user_id');\n      const email = params.get('email');\n      const name = params.get('name');\n      \n      // Check if we have OAuth callback parameters\n      if (accessToken && userId && email) {\n        // Create session with the data from backend\n        const session: AuthSession = {\n          accessToken,\n          user: {\n            id: userId,\n            email: email,\n            name: name || '',\n            // These fields are not provided by backend OAuth callback\n            // They'll be populated when calling getCurrentUser()\n            emailVerified: false,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n          } as any,\n        };\n        \n        // Save session and set auth token\n        this.tokenManager.saveSession(session);\n        this.http.setAuthToken(accessToken);\n        \n        // Clean up the URL to remove sensitive parameters\n        const url = new URL(window.location.href);\n        url.searchParams.delete('access_token');\n        url.searchParams.delete('user_id');\n        url.searchParams.delete('email');\n        url.searchParams.delete('name');\n        \n        // Also handle error case from backend (line 581)\n        if (params.has('error')) {\n          url.searchParams.delete('error');\n        }\n        \n        // Replace URL without adding to browser history\n        window.history.replaceState({}, document.title, url.toString());\n      }\n    } catch (error) {\n      // Silently continue - don't break initialization\n      console.debug('OAuth callback detection skipped:', error);\n    }\n  }\n\n  /**\n   * Sign up a new user\n   */\n  async signUp(request: CreateUserRequest): Promise<{\n    data: CreateUserResponse | null;\n    error: InsForgeError | null;\n  }> {\n    try {\n      const response = await this.http.post<CreateUserResponse>('/api/auth/users', request);\n      \n      // Save session internally\n      const session: AuthSession = {\n        accessToken: response.accessToken,\n        user: response.user,\n      };\n      this.tokenManager.saveSession(session);\n      this.http.setAuthToken(response.accessToken);\n\n      return { \n        data: response,\n        error: null \n      };\n    } catch (error) {\n      // Pass through API errors unchanged\n      if (error instanceof InsForgeError) {\n        return { data: null, error };\n      }\n      \n      // Generic fallback for unexpected errors\n      return { \n        data: null, \n        error: new InsForgeError(\n          error instanceof Error ? error.message : 'An unexpected error occurred during sign up',\n          500,\n          'UNEXPECTED_ERROR'\n        )\n      };\n    }\n  }\n\n  /**\n   * Sign in with email and password\n   */\n  async signInWithPassword(request: CreateSessionRequest): Promise<{\n    data: CreateSessionResponse | null;\n    error: InsForgeError | null;\n  }> {\n    try {\n      const response = await this.http.post<CreateSessionResponse>('/api/auth/sessions', request);\n      \n      // Save session internally\n      const session: AuthSession = {\n        accessToken: response.accessToken,\n        user: response.user,\n      };\n      this.tokenManager.saveSession(session);\n      this.http.setAuthToken(response.accessToken);\n\n      return { \n        data: response,\n        error: null \n      };\n    } catch (error) {\n      // Pass through API errors unchanged\n      if (error instanceof InsForgeError) {\n        return { data: null, error };\n      }\n      \n      // Generic fallback for unexpected errors\n      return { \n        data: null, \n        error: new InsForgeError(\n          'An unexpected error occurred during sign in',\n          500,\n          'UNEXPECTED_ERROR'\n        )\n      };\n    }\n  }\n\n  /**\n   * Sign in with OAuth provider\n   */\n  async signInWithOAuth(options: {\n    provider: 'google' | 'github';\n    redirectTo?: string;\n    skipBrowserRedirect?: boolean;\n  }): Promise<{\n    data: { url?: string; provider?: string };\n    error: InsForgeError | null;\n  }> {\n    try {\n      const { provider, redirectTo, skipBrowserRedirect } = options;\n      \n      const params = redirectTo \n        ? { redirect_uri: redirectTo } \n        : undefined;\n      \n      const endpoint = `/api/auth/oauth/${provider}`;\n      const response = await this.http.get<GetOauthUrlResponse>(endpoint, { params });\n      \n      // Automatically redirect in browser unless told not to\n      if (typeof window !== 'undefined' && !skipBrowserRedirect) {\n        window.location.href = response.authUrl;\n        return { data: {}, error: null };\n      }\n\n      return { \n        data: { \n          url: response.authUrl,\n          provider \n        }, \n        error: null \n      };\n    } catch (error) {\n      // Pass through API errors unchanged\n      if (error instanceof InsForgeError) {\n        return { data: {}, error };\n      }\n      \n      // Generic fallback for unexpected errors\n      return { \n        data: {}, \n        error: new InsForgeError(\n          'An unexpected error occurred during OAuth initialization',\n          500,\n          'UNEXPECTED_ERROR'\n        )\n      };\n    }\n  }\n\n  /**\n   * Sign out the current user\n   */\n  async signOut(): Promise<{ error: InsForgeError | null }> {\n    try {\n      this.tokenManager.clearSession();\n      this.http.setAuthToken(null);\n      return { error: null };\n    } catch (error) {\n      return { \n        error: new InsForgeError(\n          'Failed to sign out',\n          500,\n          'SIGNOUT_ERROR'\n        )\n      };\n    }\n  }\n\n  /**\n   * Get the current user with full profile information\n   * Returns both auth info (id, email, role) and profile data (nickname, avatar_url, bio, etc.)\n   */\n  async getCurrentUser(): Promise<{\n    data: { user: any; profile: any } | null;\n    error: any | null;\n  }> {\n    try {\n      // Check if we have a token\n      const session = this.tokenManager.getSession();\n      if (!session?.accessToken) {\n        return { data: null, error: null };\n      }\n\n      // Call the API for auth info\n      this.http.setAuthToken(session.accessToken);\n      const authResponse = await this.http.get<GetCurrentSessionResponse>('/api/auth/sessions/current');\n      \n      // Get the user's profile using query builder\n      const { data: profile, error: profileError } = await this.database\n        .from('users')\n        .select('*')\n        .eq('id', authResponse.user.id)\n        .single();\n      \n      // For database errors, return PostgrestError directly\n      if (profileError && (profileError as any).code !== 'PGRST116') {  // PGRST116 = not found\n        return { data: null, error: profileError };\n      }\n      \n      return {\n        data: {\n          user: authResponse.user,\n          profile: profile\n        },\n        error: null\n      };\n    } catch (error) {\n      // If unauthorized, clear session\n      if (error instanceof InsForgeError && error.statusCode === 401) {\n        await this.signOut();\n        return { data: null, error: null };\n      }\n      \n      // Pass through all other errors unchanged\n      if (error instanceof InsForgeError) {\n        return { data: null, error };\n      }\n      \n      // Generic fallback for unexpected errors\n      return { \n        data: null, \n        error: new InsForgeError(\n          'An unexpected error occurred while fetching user',\n          500,\n          'UNEXPECTED_ERROR'\n        )\n      };\n    }\n  }\n\n  /**\n   * Get any user's profile by ID\n   * Returns profile information from the users table (nickname, avatar_url, bio, etc.)\n   */\n  async getProfile(userId: string): Promise<{\n    data: any | null;\n    error: any | null;\n  }> {\n    const { data, error } = await this.database\n      .from('users')\n      .select('*')\n      .eq('id', userId)\n      .single();\n    \n    // Handle not found as null, not error\n    if (error && (error as any).code === 'PGRST116') {\n      return { data: null, error: null };\n    }\n    \n    // Return PostgrestError directly for database operations\n    return { data, error };\n  }\n\n  /**\n   * Get the current session (only session data, no API call)\n   * Returns the stored JWT token and basic user info from local storage\n   */\n  getCurrentSession(): {\n    data: { session: AuthSession | null };\n    error: InsForgeError | null;\n  } {\n    try {\n      const session = this.tokenManager.getSession();\n      \n      if (session?.accessToken) {\n        this.http.setAuthToken(session.accessToken);\n        return { data: { session }, error: null };\n      }\n\n      return { data: { session: null }, error: null };\n    } catch (error) {\n      // Pass through API errors unchanged\n      if (error instanceof InsForgeError) {\n        return { data: { session: null }, error };\n      }\n      \n      // Generic fallback for unexpected errors\n      return { \n        data: { session: null }, \n        error: new InsForgeError(\n          'An unexpected error occurred while getting session',\n          500,\n          'UNEXPECTED_ERROR'\n        )\n      };\n    }\n  }\n\n  /**\n   * Set/Update the current user's profile\n   * Updates profile information in the users table (nickname, avatar_url, bio, etc.)\n   */\n  async setProfile(profile: {\n    nickname?: string;\n    avatar_url?: string;\n    bio?: string;\n    birthday?: string;\n    [key: string]: any;\n  }): Promise<{\n    data: any | null;\n    error: any | null;\n  }> {\n    // Get current session to get user ID\n    const session = this.tokenManager.getSession();\n    if (!session?.user?.id) {\n      return { \n        data: null, \n        error: new InsForgeError(\n          'No authenticated user found',\n          401,\n          'UNAUTHENTICATED'\n        )\n      };\n    }\n\n    // Update the profile using query builder\n    const { data, error } = await this.database\n      .from('users')\n      .update(profile)\n      .eq('id', session.user.id)\n      .select()\n      .single();\n    \n    // Return PostgrestError directly for database operations\n    return { data, error };\n  }\n\n\n}", "/**\n * Storage module for InsForge SDK\n * Handles file uploads, downloads, and bucket management\n */\n\nimport { HttpClient } from '../lib/http-client';\nimport { InsForgeError } from '../types';\nimport type { \n  StorageFileSchema,\n  ListObjectsResponseSchema\n} from '@insforge/shared-schemas';\n\nexport interface StorageResponse<T> {\n  data: T | null;\n  error: InsForgeError | null;\n}\n\ninterface UploadStrategy {\n  method: 'direct' | 'presigned';\n  uploadUrl: string;\n  fields?: Record<string, string>;\n  key: string;\n  confirmRequired: boolean;\n  confirmUrl?: string;\n  expiresAt?: Date;\n}\n\ninterface DownloadStrategy {\n  method: 'direct' | 'presigned';\n  url: string;\n  expiresAt?: Date;\n}\n\n/**\n * Storage bucket operations\n */\nexport class StorageBucket {\n  constructor(\n    private bucketName: string,\n    private http: HttpClient\n  ) {}\n\n  /**\n   * Upload a file with a specific key\n   * Uses the upload strategy from backend (direct or presigned)\n   * @param path - The object key/path\n   * @param file - File or Blob to upload\n   */\n  async upload(\n    path: string,\n    file: File | Blob\n  ): Promise<StorageResponse<StorageFileSchema>> {\n    try {\n      // Get upload strategy from backend - this is required\n      const strategyResponse = await this.http.post<UploadStrategy>(\n        `/api/storage/buckets/${this.bucketName}/upload-strategy`,\n        {\n          filename: path,\n          contentType: file.type || 'application/octet-stream',\n          size: file.size\n        }\n      );\n\n      // Use presigned URL if available\n      if (strategyResponse.method === 'presigned') {\n        return await this.uploadWithPresignedUrl(strategyResponse, file);\n      }\n\n      // Use direct upload if strategy says so\n      if (strategyResponse.method === 'direct') {\n        const formData = new FormData();\n        formData.append('file', file);\n\n        const response = await this.http.request<StorageFileSchema>(\n          'PUT',\n          `/api/storage/buckets/${this.bucketName}/objects/${encodeURIComponent(path)}`,\n          {\n            body: formData as any,\n            headers: {\n              // Don't set Content-Type, let browser set multipart boundary\n            }\n          }\n        );\n\n        return { data: response, error: null };\n      }\n\n      throw new InsForgeError(\n        `Unsupported upload method: ${strategyResponse.method}`,\n        500,\n        'STORAGE_ERROR'\n      );\n    } catch (error) {\n      return { \n        data: null, \n        error: error instanceof InsForgeError ? error : new InsForgeError(\n          'Upload failed',\n          500,\n          'STORAGE_ERROR'\n        )\n      };\n    }\n  }\n\n  /**\n   * Upload a file with auto-generated key\n   * Uses the upload strategy from backend (direct or presigned)\n   * @param file - File or Blob to upload\n   */\n  async uploadAuto(\n    file: File | Blob\n  ): Promise<StorageResponse<StorageFileSchema>> {\n    try {\n      const filename = file instanceof File ? file.name : 'file';\n      \n      // Get upload strategy from backend - this is required\n      const strategyResponse = await this.http.post<UploadStrategy>(\n        `/api/storage/buckets/${this.bucketName}/upload-strategy`,\n        {\n          filename,\n          contentType: file.type || 'application/octet-stream',\n          size: file.size\n        }\n      );\n\n      // Use presigned URL if available\n      if (strategyResponse.method === 'presigned') {\n        return await this.uploadWithPresignedUrl(strategyResponse, file);\n      }\n\n      // Use direct upload if strategy says so\n      if (strategyResponse.method === 'direct') {\n        const formData = new FormData();\n        formData.append('file', file);\n\n        const response = await this.http.request<StorageFileSchema>(\n          'POST',\n          `/api/storage/buckets/${this.bucketName}/objects`,\n          {\n            body: formData as any,\n            headers: {\n              // Don't set Content-Type, let browser set multipart boundary\n            }\n          }\n        );\n\n        return { data: response, error: null };\n      }\n\n      throw new InsForgeError(\n        `Unsupported upload method: ${strategyResponse.method}`,\n        500,\n        'STORAGE_ERROR'\n      );\n    } catch (error) {\n      return { \n        data: null, \n        error: error instanceof InsForgeError ? error : new InsForgeError(\n          'Upload failed',\n          500,\n          'STORAGE_ERROR'\n        )\n      };\n    }\n  }\n\n  /**\n   * Internal method to handle presigned URL uploads\n   */\n  private async uploadWithPresignedUrl(\n    strategy: UploadStrategy,\n    file: File | Blob\n  ): Promise<StorageResponse<StorageFileSchema>> {\n    try {\n      // Upload to presigned URL (e.g., S3)\n      const formData = new FormData();\n      \n      // Add all fields from the presigned URL\n      if (strategy.fields) {\n        Object.entries(strategy.fields).forEach(([key, value]) => {\n          formData.append(key, value);\n        });\n      }\n      \n      // File must be the last field for S3\n      formData.append('file', file);\n\n      const uploadResponse = await fetch(strategy.uploadUrl, {\n        method: 'POST',\n        body: formData\n      });\n\n      if (!uploadResponse.ok) {\n        throw new InsForgeError(\n          `Upload to storage failed: ${uploadResponse.statusText}`,\n          uploadResponse.status,\n          'STORAGE_ERROR'\n        );\n      }\n\n      // Confirm upload with backend if required\n      if (strategy.confirmRequired && strategy.confirmUrl) {\n        const confirmResponse = await this.http.post<StorageFileSchema>(\n          strategy.confirmUrl,\n          {\n            size: file.size,\n            contentType: file.type || 'application/octet-stream'\n          }\n        );\n\n        return { data: confirmResponse, error: null };\n      }\n\n      // If no confirmation required, return basic file info\n      return {\n        data: {\n          key: strategy.key,\n          bucket: this.bucketName,\n          size: file.size,\n          mimeType: file.type || 'application/octet-stream',\n          uploadedAt: new Date().toISOString(),\n          url: this.getPublicUrl(strategy.key)\n        } as StorageFileSchema,\n        error: null\n      };\n    } catch (error) {\n      throw error instanceof InsForgeError ? error : new InsForgeError(\n        'Presigned upload failed',\n        500,\n        'STORAGE_ERROR'\n      );\n    }\n  }\n\n  /**\n   * Download a file\n   * Uses the download strategy from backend (direct or presigned)\n   * @param path - The object key/path\n   * Returns the file as a Blob\n   */\n  async download(path: string): Promise<{ data: Blob | null; error: InsForgeError | null }> {\n    try {\n      // Get download strategy from backend - this is required\n      const strategyResponse = await this.http.post<DownloadStrategy>(\n        `/api/storage/buckets/${this.bucketName}/objects/${encodeURIComponent(path)}/download-strategy`,\n        { expiresIn: 3600 }\n      );\n\n      // Use URL from strategy\n      const downloadUrl = strategyResponse.url;\n      \n      // Download from the URL\n      const headers: HeadersInit = {};\n      \n      // Only add auth header for direct downloads (not presigned URLs)\n      if (strategyResponse.method === 'direct') {\n        Object.assign(headers, this.http.getHeaders());\n      }\n      \n      const response = await fetch(downloadUrl, {\n        method: 'GET',\n        headers\n      });\n\n      if (!response.ok) {\n        try {\n          const error = await response.json();\n          throw InsForgeError.fromApiError(error);\n        } catch {\n          throw new InsForgeError(\n            `Download failed: ${response.statusText}`,\n            response.status,\n            'STORAGE_ERROR'\n          );\n        }\n      }\n\n      const blob = await response.blob();\n      return { data: blob, error: null };\n    } catch (error) {\n      return { \n        data: null, \n        error: error instanceof InsForgeError ? error : new InsForgeError(\n          'Download failed',\n          500,\n          'STORAGE_ERROR'\n        )\n      };\n    }\n  }\n\n  /**\n   * Get public URL for a file\n   * @param path - The object key/path\n   */\n  getPublicUrl(path: string): string {\n    return `${this.http.baseUrl}/api/storage/buckets/${this.bucketName}/objects/${encodeURIComponent(path)}`;\n  }\n\n  /**\n   * List objects in the bucket\n   * @param prefix - Filter by key prefix\n   * @param search - Search in file names\n   * @param limit - Maximum number of results (default: 100, max: 1000)\n   * @param offset - Number of results to skip\n   */\n  async list(options?: {\n    prefix?: string;\n    search?: string;\n    limit?: number;\n    offset?: number;\n  }): Promise<StorageResponse<ListObjectsResponseSchema>> {\n    try {\n      const params: Record<string, string> = {};\n      \n      if (options?.prefix) params.prefix = options.prefix;\n      if (options?.search) params.search = options.search;\n      if (options?.limit) params.limit = options.limit.toString();\n      if (options?.offset) params.offset = options.offset.toString();\n\n      const response = await this.http.get<ListObjectsResponseSchema>(\n        `/api/storage/buckets/${this.bucketName}/objects`,\n        { params }\n      );\n\n      return { data: response, error: null };\n    } catch (error) {\n      return { \n        data: null, \n        error: error instanceof InsForgeError ? error : new InsForgeError(\n          'List failed',\n          500,\n          'STORAGE_ERROR'\n        )\n      };\n    }\n  }\n\n  /**\n   * Delete a file\n   * @param path - The object key/path\n   */\n  async remove(path: string): Promise<StorageResponse<{ message: string }>> {\n    try {\n      const response = await this.http.delete<{ message: string }>(\n        `/api/storage/buckets/${this.bucketName}/objects/${encodeURIComponent(path)}`\n      );\n\n      return { data: response, error: null };\n    } catch (error) {\n      return { \n        data: null, \n        error: error instanceof InsForgeError ? error : new InsForgeError(\n          'Delete failed',\n          500,\n          'STORAGE_ERROR'\n        )\n      };\n    }\n  }\n}\n\n/**\n * Storage module for file operations\n */\nexport class Storage {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get a bucket instance for operations\n   * @param bucketName - Name of the bucket\n   */\n  from(bucketName: string): StorageBucket {\n    return new StorageBucket(bucketName, this.http);\n  }\n}", "/**\n * AI Module for Insforge SDK\n * Response format roughly matches OpenAI SDK for compatibility\n *\n * The backend handles all the complexity of different AI providers\n * and returns a unified format. This SDK transforms responses to match OpenAI-like format.\n */\n\nimport { HttpClient } from \"../lib/http-client\";\nimport {\n  ChatCompletionRequest,\n  ChatCompletionResponse,\n  ImageGenerationRequest,\n  ImageGenerationResponse,\n} from \"@insforge/shared-schemas\";\n\nexport class AI {\n  public readonly chat: Chat;\n  public readonly images: Images;\n\n  constructor(private http: HttpClient) {\n    this.chat = new Chat(http);\n    this.images = new Images(http);\n  }\n}\n\nclass Chat {\n  public readonly completions: ChatCompletions;\n\n  constructor(http: HttpClient) {\n    this.completions = new ChatCompletions(http);\n  }\n}\n\nclass ChatCompletions {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Create a chat completion - OpenAI-like response format\n   *\n   * @example\n   * ```typescript\n   * // Non-streaming\n   * const completion = await client.ai.chat.completions.create({\n   *   model: 'gpt-4',\n   *   messages: [{ role: 'user', content: 'Hello!' }]\n   * });\n   * console.log(completion.choices[0].message.content);\n   *\n   * // With images\n   * const response = await client.ai.chat.completions.create({\n   *   model: 'gpt-4-vision',\n   *   messages: [{\n   *     role: 'user',\n   *     content: 'What is in this image?',\n   *     images: [{ url: 'https://example.com/image.jpg' }]\n   *   }]\n   * });\n   *\n   * // Streaming - returns async iterable\n   * const stream = await client.ai.chat.completions.create({\n   *   model: 'gpt-4',\n   *   messages: [{ role: 'user', content: 'Tell me a story' }],\n   *   stream: true\n   * });\n   *\n   * for await (const chunk of stream) {\n   *   if (chunk.choices[0]?.delta?.content) {\n   *     process.stdout.write(chunk.choices[0].delta.content);\n   *   }\n   * }\n   * ```\n   */\n  async create(params: ChatCompletionRequest): Promise<any> {\n    // Backend already expects camelCase, no transformation needed\n    const backendParams = {\n      model: params.model,\n      messages: params.messages,\n      temperature: params.temperature,\n      maxTokens: params.maxTokens,\n      topP: params.topP,\n      stream: params.stream,\n    };\n\n    // For streaming, return an async iterable that yields OpenAI-like chunks\n    if (params.stream) {\n      const headers = this.http.getHeaders();\n      headers[\"Content-Type\"] = \"application/json\";\n\n      const response = await this.http.fetch(\n        `${this.http.baseUrl}/api/ai/chat/completion`,\n        {\n          method: \"POST\",\n          headers,\n          body: JSON.stringify(backendParams),\n        }\n      );\n\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.error || \"Stream request failed\");\n      }\n\n      // Return async iterable that parses SSE and transforms to OpenAI-like format\n      return this.parseSSEStream(response, params.model);\n    }\n\n    // Non-streaming: transform response to OpenAI-like format\n    const response: ChatCompletionResponse = await this.http.post(\n      \"/api/ai/chat/completion\",\n      backendParams\n    );\n\n    // Transform to OpenAI-like format\n    const content = response.text || \"\";\n\n    return {\n      id: `chatcmpl-${Date.now()}`,\n      object: \"chat.completion\",\n      created: Math.floor(Date.now() / 1000),\n      model: response.metadata?.model,\n      choices: [\n        {\n          index: 0,\n          message: {\n            role: \"assistant\",\n            content,\n          },\n          finish_reason: \"stop\",\n        },\n      ],\n      usage: response.metadata?.usage || {\n        prompt_tokens: 0,\n        completion_tokens: 0,\n        total_tokens: 0,\n      },\n    };\n  }\n\n  /**\n   * Parse SSE stream into async iterable of OpenAI-like chunks\n   */\n  private async *parseSSEStream(\n    response: Response,\n    model: string\n  ): AsyncIterableIterator<any> {\n    const reader = response.body!.getReader();\n    const decoder = new TextDecoder();\n    let buffer = \"\";\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split(\"\\n\");\n        buffer = lines.pop() || \"\";\n\n        for (const line of lines) {\n          if (line.startsWith(\"data: \")) {\n            const dataStr = line.slice(6).trim();\n            if (dataStr) {\n              try {\n                const data = JSON.parse(dataStr);\n\n                // Transform to OpenAI-like streaming format\n                if (data.chunk || data.content) {\n                  yield {\n                    id: `chatcmpl-${Date.now()}`,\n                    object: \"chat.completion.chunk\",\n                    created: Math.floor(Date.now() / 1000),\n                    model,\n                    choices: [\n                      {\n                        index: 0,\n                        delta: {\n                          content: data.chunk || data.content,\n                        },\n                        finish_reason: data.done ? \"stop\" : null,\n                      },\n                    ],\n                  };\n                }\n\n                // If we received the done signal, we can stop\n                if (data.done) {\n                  reader.releaseLock();\n                  return;\n                }\n              } catch (e) {\n                // Skip invalid JSON\n                console.warn(\"Failed to parse SSE data:\", dataStr);\n              }\n            }\n          }\n        }\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  }\n}\n\nclass Images {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Generate images - OpenAI-like response format\n   *\n   * @example\n   * ```typescript\n   * // Text-to-image\n   * const response = await client.ai.images.generate({\n   *   model: 'dall-e-3',\n   *   prompt: 'A sunset over mountains',\n   * });\n   * console.log(response.images[0].url);\n   *\n   * // Image-to-image (with input images)\n   * const response = await client.ai.images.generate({\n   *   model: 'stable-diffusion-xl',\n   *   prompt: 'Transform this into a watercolor painting',\n   *   images: [\n   *     { url: 'https://example.com/input.jpg' },\n   *     // or base64-encoded Data URI:\n   *     { url: 'data:image/jpeg;base64,/9j/4AAQ...' }\n   *   ]\n   * });\n   * ```\n   */\n  async generate(params: ImageGenerationRequest): Promise<any> {\n    const response: ImageGenerationResponse = await this.http.post(\n      \"/api/ai/image/generation\",\n      params\n    );\n    \n    // Build data array based on response content\n    let data: Array<{ b64_json?: string; content?: string }> = [];\n    \n    if (response.images && response.images.length > 0) {\n      // Has images - extract base64 and include text\n      data = response.images.map(img => ({\n        b64_json: img.imageUrl.replace(/^data:image\\/\\w+;base64,/, ''),\n        content: response.text\n      }));\n    } else if (response.text) {\n      // Text-only response\n      data = [{ content: response.text }];\n    }\n    \n    // Return OpenAI-compatible format\n    return {\n      created: Math.floor(Date.now() / 1000),\n      data,\n      ...(response.metadata?.usage && {\n        usage: {\n          total_tokens: response.metadata.usage.totalTokens || 0,\n          input_tokens: response.metadata.usage.promptTokens || 0,\n          output_tokens: response.metadata.usage.completionTokens || 0,\n        }\n      })\n    };\n  }\n}\n", "import { HttpClient } from '../lib/http-client';\n\nexport interface FunctionInvokeOptions {\n  /**\n   * The body of the request\n   */\n  body?: any;\n  \n  /**\n   * Custom headers to send with the request\n   */\n  headers?: Record<string, string>;\n  \n  /**\n   * HTTP method (default: POST)\n   */\n  method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n}\n\n/**\n * Edge Functions client for invoking serverless functions\n * \n * @example\n * ```typescript\n * // Invoke a function with JSON body\n * const { data, error } = await client.functions.invoke('hello-world', {\n *   body: { name: 'World' }\n * });\n * \n * // GET request\n * const { data, error } = await client.functions.invoke('get-data', {\n *   method: 'GET'\n * });\n * ```\n */\nexport class Functions {\n  private http: HttpClient;\n\n  constructor(http: HttpClient) {\n    this.http = http;\n  }\n\n  /**\n   * Invokes an Edge Function\n   * @param slug The function slug to invoke\n   * @param options Request options\n   */\n  async invoke<T = any>(\n    slug: string,\n    options: FunctionInvokeOptions = {}\n  ): Promise<{ data: T | null; error: Error | null }> {\n    try {\n      const { method = 'POST', body, headers = {} } = options;\n      \n      // Simple path: /functions/{slug}\n      const path = `/functions/${slug}`;\n      \n      // Use the HTTP client's request method\n      const data = await this.http.request<T>(\n        method,\n        path,\n        { body, headers }\n      );\n      \n      return { data, error: null };\n    } catch (error: any) {\n      // The HTTP client throws InsForgeError with all properties from the response\n      // including error, message, details, statusCode, etc.\n      // We need to preserve all of that information\n      return { \n        data: null, \n        error: error  // Pass through the full error object with all properties\n      };\n    }\n  }\n}", "import { InsForgeConfig } from './types';\nimport { HttpClient } from './lib/http-client';\nimport { TokenManager } from './lib/token-manager';\nimport { Auth } from './modules/auth';\nimport { Database } from './modules/database-postgrest';\nimport { Storage } from './modules/storage';\nimport { AI } from './modules/ai';\nimport { Functions } from './modules/functions';\n\n/**\n * Main InsForge SDK Client\n * \n * @example\n * ```typescript\n * import { InsForgeClient } from '@insforge/sdk';\n * \n * const client = new InsForgeClient({\n *   baseUrl: 'http://localhost:7130'\n * });\n * \n * // Authentication\n * const session = await client.auth.register({\n *   email: 'user@example.com',\n *   password: 'password123',\n *   name: 'John Doe'\n * });\n * \n * // Database operations\n * const { data, error } = await client.database\n *   .from('posts')\n *   .select('*')\n *   .eq('user_id', session.user.id)\n *   .order('created_at', { ascending: false })\n *   .limit(10);\n * \n * // Insert data\n * const { data: newPost } = await client.database\n *   .from('posts')\n *   .insert({ title: 'Hello', content: 'World' })\n *   .single();\n * \n * // Invoke edge functions\n * const { data, error } = await client.functions.invoke('my-function', {\n *   body: { message: 'Hello from SDK' }\n * });\n * ```\n */\nexport class InsForgeClient {\n  private http: HttpClient;\n  private tokenManager: TokenManager;\n  \n  public readonly auth: Auth;\n  public readonly database: Database;\n  public readonly storage: Storage;\n  public readonly ai: AI;\n  public readonly functions: Functions;\n\n  constructor(config: InsForgeConfig = {}) {\n    this.http = new HttpClient(config);\n    this.tokenManager = new TokenManager(config.storage);\n    \n    // Check for edge function token\n    if (config.edgeFunctionToken) {\n      this.http.setAuthToken(config.edgeFunctionToken);\n      // Save to token manager so getCurrentUser() works\n      this.tokenManager.saveSession({\n        accessToken: config.edgeFunctionToken,\n        user: {} as any // Will be populated by getCurrentUser()\n      });\n    }\n    \n    // Check for existing session in storage\n    const existingSession = this.tokenManager.getSession();\n    if (existingSession?.accessToken) {\n      this.http.setAuthToken(existingSession.accessToken);\n    }\n    \n    this.auth = new Auth(\n      this.http,\n      this.tokenManager\n    );\n    \n    this.database = new Database(this.http, this.tokenManager);\n    this.storage = new Storage(this.http);\n    this.ai = new AI(this.http);\n    this.functions = new Functions(this.http);\n  }\n\n  /**\n   * Get the underlying HTTP client for custom requests\n   * \n   * @example\n   * ```typescript\n   * const httpClient = client.getHttpClient();\n   * const customData = await httpClient.get('/api/custom-endpoint');\n   * ```\n   */\n  getHttpClient(): HttpClient {\n    return this.http;\n  }\n\n  /**\n   * Future modules will be added here:\n   * - database: Database operations\n   * - storage: File storage operations\n   * - functions: Serverless functions\n   * - tables: Table management\n   * - metadata: Backend metadata\n   */\n}", "/**\n * @insforge/sdk - TypeScript SDK for InsForge Backend-as-a-Service\n * \n * @packageDocumentation\n */\n\n// Main client\nexport { InsForgeClient } from './client';\n\n// Types\nexport type {\n  InsForgeConfig,\n  InsForgeConfig as ClientOptions,  // Alias for compatibility\n  TokenStorage,\n  AuthSession,\n  ApiError,\n} from './types';\n\nexport { InsForgeError } from './types';\n\n// Re-export shared schemas that SDK users will need\nexport type {\n  UserSchema,\n  CreateUserRequest,\n  CreateSessionRequest,\n  AuthErrorResponse,\n} from '@insforge/shared-schemas';\n\n// Re-export auth module for advanced usage\nexport { Auth } from './modules/auth';\n\n// Re-export database module (using postgrest-js)\nexport { Database } from './modules/database-postgrest';\n// Note: QueryBuilder is no longer exported as we use postgrest-js QueryBuilder internally\n\n// Re-export storage module and types\nexport { Storage, StorageBucket } from './modules/storage';\nexport type { StorageResponse } from './modules/storage';\n\n// Re-export AI module\nexport { AI } from './modules/ai';\n\n// Re-export Functions module\nexport { Functions } from './modules/functions';\nexport type { FunctionInvokeOptions } from './modules/functions';\n\n// Re-export utilities for advanced usage\nexport { HttpClient } from './lib/http-client';\nexport { TokenManager } from './lib/token-manager';\n\n// Factory function for creating clients (Supabase-style)\nimport { InsForgeClient } from './client';\nimport { InsForgeConfig } from './types';\n\nexport function createClient(config: InsForgeConfig): InsForgeClient {\n  return new InsForgeClient(config);\n}\n\n// Default export for convenience\nexport default InsForgeClient;"],
  "mappings": "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",
  "names": ["Headers", "fetch", "PostgrestError", "PostgrestBuilder", "res", "PostgrestTransformBuilder", "PostgrestFilterBuilder", "PostgrestQueryBuilder", "fetch", "PostgrestClient", "fetch", "index", "response"]
}
