import { UserSchema, CreateUserRequest, CreateUserResponse, CreateSessionRequest, CreateSessionResponse, StorageFileSchema, ListObjectsResponseSchema, ChatCompletionRequest, ImageGenerationRequest } from '@insforge/shared-schemas';
export { AuthErrorResponse, CreateSessionRequest, CreateUserRequest, UserSchema } from '@insforge/shared-schemas';
import * as _supabase_postgrest_js from '@supabase/postgrest-js';

/**
 * InsForge SDK Types - only SDK-specific types here
 * Use @insforge/shared-schemas directly for API types
 */

interface InsForgeConfig {
    /**
     * The base URL of the InsForge backend API
     * @default "http://localhost:7130"
     */
    baseUrl?: string;
    /**
     * Anonymous API key (optional)
     * Used for public/unauthenticated requests when no user token is set
     */
    anonKey?: string;
    /**
     * Edge Function Token (optional)
     * Use this when running in edge functions/serverless with a user's JWT token
     * This token will be used for all authenticated requests
     */
    edgeFunctionToken?: string;
    /**
     * Custom fetch implementation (useful for Node.js environments)
     */
    fetch?: typeof fetch;
    /**
     * Storage adapter for persisting tokens
     */
    storage?: TokenStorage;
    /**
     * Whether to automatically refresh tokens before they expire
     * @default true
     */
    autoRefreshToken?: boolean;
    /**
     * Whether to persist session in storage
     * @default true
     */
    persistSession?: boolean;
    /**
     * Custom headers to include with every request
     */
    headers?: Record<string, string>;
}
interface TokenStorage {
    getItem(key: string): string | null | Promise<string | null>;
    setItem(key: string, value: string): void | Promise<void>;
    removeItem(key: string): void | Promise<void>;
}
interface AuthSession {
    user: UserSchema;
    accessToken: string;
    expiresAt?: Date;
}
interface ApiError {
    error: string;
    message: string;
    statusCode: number;
    nextActions?: string;
}
declare class InsForgeError extends Error {
    statusCode: number;
    error: string;
    nextActions?: string;
    constructor(message: string, statusCode: number, error: string, nextActions?: string);
    static fromApiError(apiError: ApiError): InsForgeError;
}

interface RequestOptions extends RequestInit {
    params?: Record<string, string>;
}
declare class HttpClient {
    readonly baseUrl: string;
    readonly fetch: typeof fetch;
    private defaultHeaders;
    private anonKey;
    private userToken;
    constructor(config: InsForgeConfig);
    private buildUrl;
    request<T>(method: string, path: string, options?: RequestOptions): Promise<T>;
    get<T>(path: string, options?: RequestOptions): Promise<T>;
    post<T>(path: string, body?: any, options?: RequestOptions): Promise<T>;
    put<T>(path: string, body?: any, options?: RequestOptions): Promise<T>;
    patch<T>(path: string, body?: any, options?: RequestOptions): Promise<T>;
    delete<T>(path: string, options?: RequestOptions): Promise<T>;
    setAuthToken(token: string | null): void;
    getHeaders(): Record<string, string>;
}

declare class TokenManager {
    private storage;
    constructor(storage?: TokenStorage);
    saveSession(session: AuthSession): void;
    getSession(): AuthSession | null;
    getAccessToken(): string | null;
    clearSession(): void;
}

/**
 * Auth module for InsForge SDK
 * Uses shared schemas for type safety
 */

declare class Auth {
    private http;
    private tokenManager;
    private database;
    constructor(http: HttpClient, tokenManager: TokenManager);
    /**
     * Automatically detect and handle OAuth callback parameters in the URL
     * This runs on initialization to seamlessly complete the OAuth flow
     * Matches the backend's OAuth callback response (backend/src/api/routes/auth.ts:540-544)
     */
    private detectOAuthCallback;
    /**
     * Sign up a new user
     */
    signUp(request: CreateUserRequest): Promise<{
        data: CreateUserResponse | null;
        error: InsForgeError | null;
    }>;
    /**
     * Sign in with email and password
     */
    signInWithPassword(request: CreateSessionRequest): Promise<{
        data: CreateSessionResponse | null;
        error: InsForgeError | null;
    }>;
    /**
     * Sign in with OAuth provider
     */
    signInWithOAuth(options: {
        provider: 'google' | 'github';
        redirectTo?: string;
        skipBrowserRedirect?: boolean;
    }): Promise<{
        data: {
            url?: string;
            provider?: string;
        };
        error: InsForgeError | null;
    }>;
    /**
     * Sign out the current user
     */
    signOut(): Promise<{
        error: InsForgeError | null;
    }>;
    /**
     * Get the current user with full profile information
     * Returns both auth info (id, email, role) and profile data (nickname, avatar_url, bio, etc.)
     */
    getCurrentUser(): Promise<{
        data: {
            user: any;
            profile: any;
        } | null;
        error: any | null;
    }>;
    /**
     * Get any user's profile by ID
     * Returns profile information from the users table (nickname, avatar_url, bio, etc.)
     */
    getProfile(userId: string): Promise<{
        data: any | null;
        error: any | null;
    }>;
    /**
     * Get the current session (only session data, no API call)
     * Returns the stored JWT token and basic user info from local storage
     */
    getCurrentSession(): {
        data: {
            session: AuthSession | null;
        };
        error: InsForgeError | null;
    };
    /**
     * Set/Update the current user's profile
     * Updates profile information in the users table (nickname, avatar_url, bio, etc.)
     */
    setProfile(profile: {
        nickname?: string;
        avatar_url?: string;
        bio?: string;
        birthday?: string;
        [key: string]: any;
    }): Promise<{
        data: any | null;
        error: any | null;
    }>;
}

/**
 * Database client using postgrest-js
 * Drop-in replacement with FULL PostgREST capabilities
 */
declare class Database {
    private postgrest;
    constructor(httpClient: HttpClient, tokenManager: TokenManager);
    /**
     * Create a query builder for a table
     *
     * @example
     * // Basic query
     * const { data, error } = await client.database
     *   .from('posts')
     *   .select('*')
     *   .eq('user_id', userId);
     *
     * // With count (Supabase style!)
     * const { data, error, count } = await client.database
     *   .from('posts')
     *   .select('*', { count: 'exact' })
     *   .range(0, 9);
     *
     * // Just get count, no data
     * const { count } = await client.database
     *   .from('posts')
     *   .select('*', { count: 'exact', head: true });
     *
     * // Complex queries with OR
     * const { data } = await client.database
     *   .from('posts')
     *   .select('*, users!inner(*)')
     *   .or('status.eq.active,status.eq.pending');
     *
     * // All features work:
     * - Nested selects
     * - Foreign key expansion
     * - OR/AND/NOT conditions
     * - Count with head
     * - Range pagination
     * - Upserts
     */
    from(table: string): _supabase_postgrest_js.PostgrestQueryBuilder<any, any, any, string, unknown>;
}

/**
 * Storage module for InsForge SDK
 * Handles file uploads, downloads, and bucket management
 */

interface StorageResponse<T> {
    data: T | null;
    error: InsForgeError | null;
}
/**
 * Storage bucket operations
 */
declare class StorageBucket {
    private bucketName;
    private http;
    constructor(bucketName: string, http: HttpClient);
    /**
     * Upload a file with a specific key
     * Uses the upload strategy from backend (direct or presigned)
     * @param path - The object key/path
     * @param file - File or Blob to upload
     */
    upload(path: string, file: File | Blob): Promise<StorageResponse<StorageFileSchema>>;
    /**
     * Upload a file with auto-generated key
     * Uses the upload strategy from backend (direct or presigned)
     * @param file - File or Blob to upload
     */
    uploadAuto(file: File | Blob): Promise<StorageResponse<StorageFileSchema>>;
    /**
     * Internal method to handle presigned URL uploads
     */
    private uploadWithPresignedUrl;
    /**
     * Download a file
     * Uses the download strategy from backend (direct or presigned)
     * @param path - The object key/path
     * Returns the file as a Blob
     */
    download(path: string): Promise<{
        data: Blob | null;
        error: InsForgeError | null;
    }>;
    /**
     * Get public URL for a file
     * @param path - The object key/path
     */
    getPublicUrl(path: string): string;
    /**
     * List objects in the bucket
     * @param prefix - Filter by key prefix
     * @param search - Search in file names
     * @param limit - Maximum number of results (default: 100, max: 1000)
     * @param offset - Number of results to skip
     */
    list(options?: {
        prefix?: string;
        search?: string;
        limit?: number;
        offset?: number;
    }): Promise<StorageResponse<ListObjectsResponseSchema>>;
    /**
     * Delete a file
     * @param path - The object key/path
     */
    remove(path: string): Promise<StorageResponse<{
        message: string;
    }>>;
}
/**
 * Storage module for file operations
 */
declare class Storage {
    private http;
    constructor(http: HttpClient);
    /**
     * Get a bucket instance for operations
     * @param bucketName - Name of the bucket
     */
    from(bucketName: string): StorageBucket;
}

/**
 * AI Module for Insforge SDK
 * Response format roughly matches OpenAI SDK for compatibility
 *
 * The backend handles all the complexity of different AI providers
 * and returns a unified format. This SDK transforms responses to match OpenAI-like format.
 */

declare class AI {
    private http;
    readonly chat: Chat;
    readonly images: Images;
    constructor(http: HttpClient);
}
declare class Chat {
    readonly completions: ChatCompletions;
    constructor(http: HttpClient);
}
declare class ChatCompletions {
    private http;
    constructor(http: HttpClient);
    /**
     * Create a chat completion - OpenAI-like response format
     *
     * @example
     * ```typescript
     * // Non-streaming
     * const completion = await client.ai.chat.completions.create({
     *   model: 'gpt-4',
     *   messages: [{ role: 'user', content: 'Hello!' }]
     * });
     * console.log(completion.choices[0].message.content);
     *
     * // With images
     * const response = await client.ai.chat.completions.create({
     *   model: 'gpt-4-vision',
     *   messages: [{
     *     role: 'user',
     *     content: 'What is in this image?',
     *     images: [{ url: 'https://example.com/image.jpg' }]
     *   }]
     * });
     *
     * // Streaming - returns async iterable
     * const stream = await client.ai.chat.completions.create({
     *   model: 'gpt-4',
     *   messages: [{ role: 'user', content: 'Tell me a story' }],
     *   stream: true
     * });
     *
     * for await (const chunk of stream) {
     *   if (chunk.choices[0]?.delta?.content) {
     *     process.stdout.write(chunk.choices[0].delta.content);
     *   }
     * }
     * ```
     */
    create(params: ChatCompletionRequest): Promise<any>;
    /**
     * Parse SSE stream into async iterable of OpenAI-like chunks
     */
    private parseSSEStream;
}
declare class Images {
    private http;
    constructor(http: HttpClient);
    /**
     * Generate images - OpenAI-like response format
     *
     * @example
     * ```typescript
     * // Text-to-image
     * const response = await client.ai.images.generate({
     *   model: 'dall-e-3',
     *   prompt: 'A sunset over mountains',
     * });
     * console.log(response.images[0].url);
     *
     * // Image-to-image (with input images)
     * const response = await client.ai.images.generate({
     *   model: 'stable-diffusion-xl',
     *   prompt: 'Transform this into a watercolor painting',
     *   images: [
     *     { url: 'https://example.com/input.jpg' },
     *     // or base64-encoded Data URI:
     *     { url: 'data:image/jpeg;base64,/9j/4AAQ...' }
     *   ]
     * });
     * ```
     */
    generate(params: ImageGenerationRequest): Promise<any>;
}

interface FunctionInvokeOptions {
    /**
     * The body of the request
     */
    body?: any;
    /**
     * Custom headers to send with the request
     */
    headers?: Record<string, string>;
    /**
     * HTTP method (default: POST)
     */
    method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
}
/**
 * Edge Functions client for invoking serverless functions
 *
 * @example
 * ```typescript
 * // Invoke a function with JSON body
 * const { data, error } = await client.functions.invoke('hello-world', {
 *   body: { name: 'World' }
 * });
 *
 * // GET request
 * const { data, error } = await client.functions.invoke('get-data', {
 *   method: 'GET'
 * });
 * ```
 */
declare class Functions {
    private http;
    constructor(http: HttpClient);
    /**
     * Invokes an Edge Function
     * @param slug The function slug to invoke
     * @param options Request options
     */
    invoke<T = any>(slug: string, options?: FunctionInvokeOptions): Promise<{
        data: T | null;
        error: Error | null;
    }>;
}

/**
 * Main InsForge SDK Client
 *
 * @example
 * ```typescript
 * import { InsForgeClient } from '@insforge/sdk';
 *
 * const client = new InsForgeClient({
 *   baseUrl: 'http://localhost:7130'
 * });
 *
 * // Authentication
 * const session = await client.auth.register({
 *   email: 'user@example.com',
 *   password: 'password123',
 *   name: 'John Doe'
 * });
 *
 * // Database operations
 * const { data, error } = await client.database
 *   .from('posts')
 *   .select('*')
 *   .eq('user_id', session.user.id)
 *   .order('created_at', { ascending: false })
 *   .limit(10);
 *
 * // Insert data
 * const { data: newPost } = await client.database
 *   .from('posts')
 *   .insert({ title: 'Hello', content: 'World' })
 *   .single();
 *
 * // Invoke edge functions
 * const { data, error } = await client.functions.invoke('my-function', {
 *   body: { message: 'Hello from SDK' }
 * });
 * ```
 */
declare class InsForgeClient {
    private http;
    private tokenManager;
    readonly auth: Auth;
    readonly database: Database;
    readonly storage: Storage;
    readonly ai: AI;
    readonly functions: Functions;
    constructor(config?: InsForgeConfig);
    /**
     * Get the underlying HTTP client for custom requests
     *
     * @example
     * ```typescript
     * const httpClient = client.getHttpClient();
     * const customData = await httpClient.get('/api/custom-endpoint');
     * ```
     */
    getHttpClient(): HttpClient;
}

/**
 * @insforge/sdk - TypeScript SDK for InsForge Backend-as-a-Service
 *
 * @packageDocumentation
 */

declare function createClient(config: InsForgeConfig): InsForgeClient;

export { AI, type ApiError, Auth, type AuthSession, type InsForgeConfig as ClientOptions, Database, type FunctionInvokeOptions, Functions, HttpClient, InsForgeClient, type InsForgeConfig, InsForgeError, Storage, StorageBucket, type StorageResponse, TokenManager, type TokenStorage, createClient, InsForgeClient as default };
